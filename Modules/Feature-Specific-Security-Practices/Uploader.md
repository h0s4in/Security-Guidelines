### - General Security Practices:

* White List extensions (Do not use Black listing on its own)
  * Only allow safe and _business-critical_ extensions (Example: just allow .docx, .pdf for CV upload)
  * Don't allow any non-required file types
* Validate the file type, don't trust the Content-Type header (can be spoofed)
* Use simple error messages for uploader (Do not include the file path, information in error messages)
* Change file name to something generated by application (Example: UUID V4)
* Set filename length limit
* Set file size limit
* Only allow authorized users to upload files
* Store files on a different server
  * Not possible? store files outside of webroot
* Access the files using a handler that is mapped to the file (UUID --\> File)
* Protect file upload form CSRF
* Scan the file with antivirus or run it in sandbox (if possible)
* Implement a defense in depth approach (No single protection is safe against uploader threats)
* Attackers tricks?
  * Double extensions
    * Consider this regex `\.jpg` is used for extension validation
    * What if file name is `file.jpg.php` ?

---

### Validations:

#### 1. Extension Validation

* Validate extensions after decoding file name
  * Why? because an attacker might upload a file named `.php%00.jpg`
  * Never use extension black-listing alone. use black-listing along side strict white-listing of allowed extensions.

---

#### 2. Content-Type Validation

* Do not rely on just checking the Content-Type (MIME Type) because its spoofable.
* Use this validation as a quick check in the upload flow.

  ```python
  # WARNING: This check is NOT enough on its own!
  # MIME type can be spoofed by modifying the Content-Type header.
  from flask import request
  
  ALLOWED_MIME_TYPES = {'text/plain'}
  file = request.files.get('uploadedfile')
  if file and file.mimetype in ALLOWED_MIME_TYPES:
      # Proceed with further validation and processing
      pass
  else:
      return "Invalid file type", 400
  ```

---

#### 3. File Signature Validation

* Another security validation layer, but not safe to use it on its own.
* Attackers can craft a malicious file that starts with "valid" magic bytes (e.g., for a PNG, PDF, JPG, etc.) but contains malicious content afterward.

  ```python
  # Unsafe Code Example
  def is_valid_image(file_path):
      allowed = [b'\xFF\xD8\xFF', b'\x89PNG', b'%PDF']
      with open(file_path, 'rb') as f:
          header = f.read(4)
      return any(header.startswith(sig) for sig in allowed)
  ```

---

#### 4. File Content Validation

* Checking raw content type against predefined types using libraries.
  * Example: ASP .NET Drawing library (Can be used for [verifying images](https://learn.microsoft.com/en-us/dotnet/api/system.drawing.imaging.imageformat?view=windowsdesktop-9.0))
* For **images**, applying image rewriting techniques destroys any kind of malicious content ([Read More](https://security.stackexchange.com/a/8625/118367))
* Use Virus Total API to scan files against already known malicious file hashes. (#todo)

---

#### 5. File Names Safety

* If you are **able** to rename the file (Best Practice):
  * Rename files to a random generated value (UUID/GUID)
* If you are **not able** to rename the file:
  * Set Max length for file name
  * Set white-listed characters for file names to prevent path traversals or client side vulnerabilities (xss)
  * Consider input validation
    * Prevent XSS in client-side
    * Prevent file overwrite or creation on server-side

---

#### 6. File Storage

* Store files on a different host (Best practice)
* If a different host is not available -\> store files outside of web root (Admin only access)
* If you must store files inside web root? set write only permissions for uploaded files

---
